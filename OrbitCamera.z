class OrbitCamera : ScriptComponent
{
    [Property]
    var RotationSensitivity : Real = 0.01;
    
    [Property]
    var TranslationSensitivity : Real = 0.1;
    
    [Property]
    var PanSensitivity : Real = 3.0;
    
    //The minimum radius on the sphere. This controls the max that the camera can zoom in.
    [Property]
    var MinDistance : Real = 1.0;
    //The maximum radius on the sphere. This controls the max that the camera can zoom out.
    [Property]
    var MaxDistance : Real = 100.0;
    
    //Where the camera is looking at.
    var Target : Real3 = local Real3(0.0, 0.0, 0.0);
    //The radius of the sphere that we are orbiting about. Controls the current zoom level.
    var Radius : Real = 5.0;
    
    //Spherical coordinates. These control our position on the sphere we're rotating about.
    var Phi : Real = Math.Pi * 0.5;
    var Theta : Real = Math.Pi * 0.5;
    //Used to store mouse state so we can use it during logic update.
    var LeftMouseDown : Boolean = false;
    var RightMouseDown : Boolean = false;
    var MouseDelta : Real2 = local Real2(0.0, 0.0);
    
    //We avoid being able to flip the camera upside-down by controlling the
    //maximum angle we can travel towards the poles on the rotation sphere.
    var RotationDeadZone : Real = 0.01;
    
    constructor() : base()
    {
    }
    
    function OnAllObjectsCreated()
    {
        //we do all of our transform update logic during logic update
        Zero.Connect(this.Space, Events.LogicUpdate, this.OnLogicUpdate);
        
        var viewport = this.Owner.Camera.Viewport;
        //connect on the viewport for all the mouse events we need
        Zero.Connect(viewport, Events.MouseDown, this.OnMouseDown);
        Zero.Connect(viewport, Events.MouseUp, this.OnMouseUp);
        Zero.Connect(viewport, Events.RightMouseDown, this.OnRightMouseDown);
        Zero.Connect(viewport, Events.RightMouseUp, this.OnRightMouseUp);
        Zero.Connect(viewport, Events.MouseMove, this.OnMouseMove);
        Zero.Connect(viewport, Events.MouseScroll, this.OnMouseScroll);
    }
    
    function OnLogicUpdate(updateEvent : UpdateEvent)
    {
        //If the right mouse is down or q is down then we update our position on the
        //rotation sphere. This is controlled by the movement of the mouse.
        if(this.RightMouseDown || (Zero.Keyboard.KeyIsDown(Keys.Q) && (this.LeftMouseDown || this.RightMouseDown)))
        {
            this.Phi -= this.MouseDelta.Y * this.RotationSensitivity;
            //Clamp the pole angle so that we don't flip the camera upside-down
            this.Phi = Math.Clamp(this.Phi, this.RotationDeadZone, Math.Pi - this.RotationDeadZone);
            this.Theta += this.MouseDelta.X * this.RotationSensitivity;
        }
        
        //calculate the position of the camera using spherical coordinates
        var cameraDir = local Real3();
        cameraDir.X = this.Radius * Math.Cos(this.Theta) * Math.Sin(this.Phi);
        cameraDir.Y = this.Radius * Math.Cos(this.Phi);
        cameraDir.Z = this.Radius * Math.Sin(this.Theta) * Math.Sin(this.Phi);
        
        //since we're looking at our target, the forward vector is just the
        //opposite of our position vector on the unit sphere
        var forward = -cameraDir;
        forward = Math.Normalize(forward);
        
        //compute the forward and right vector of the camera in world space
        var movementForward = forward;
        var movementRight = local Real3(-forward.Z, 0.0, forward.X);
        
        //build up the total world space movement of the camera
        var movementW = local Real3();
        //move the target point along the camera's forward and right projected onto the camera's x-z plane 
        if(Zero.Keyboard.KeyIsDown(Keys.W))
        {
            movementW += movementForward;
        }
        else if(Zero.Keyboard.KeyIsDown(Keys.S))
        {
            movementW -= movementForward;
        }
        if(Zero.Keyboard.KeyIsDown(Keys.A))
        {
            movementW -= movementRight;
        }
        else if(Zero.Keyboard.KeyIsDown(Keys.D))
        {
            movementW += movementRight;
        }
        //scale the movement by sensitivity
        movementW = movementW * this.PanSensitivity;
        
        //compute the basis of the camera
        var up = local Real3(0.0, 1.0, 0.0);
        //use the world up and camera's forward to get the right vector
        var right = Math.Cross(forward, up);
        right = Math.Normalize(right);
        //now use the camera forward and right to get the camera's actual up vector
        up = Math.Cross(right, forward);
        up = Math.Normalize(up);
        
        //if e is pressed and the left mouse is down, then we'll use the mouse
        //movement to pan along the camera's x and y vector
        if(Zero.Keyboard.KeyIsDown(Keys.E) && this.LeftMouseDown)
        {
            movementForward = up;
            movementRight = right;
            
            movementW += movementForward * this.MouseDelta.Y;
            //we negate the x mouse delta because we want to move the mouse
            //left and have the camera move to the right
            //(dragging the background to the left is the same as moving the camera to the right)
            movementW += movementRight * -this.MouseDelta.X;
        }
        
        //compute the sensitivity for tranlational movement, this is based upon
        //how far zoomed out we are (so we move faster when we're more zoomed out)
        var moveSensitivity = 2.0 + this.TranslationSensitivity * this.Radius;
        //when translating, we move our target position (which implicitly moves our position)
        this.Target += movementW * updateEvent.Dt * moveSensitivity;
        //set our position to be focused on our target, but back along our
        //view vector based upon the sphere's current radius
        var transform = this.Owner.Transform;
        transform.Translation = this.Target + cameraDir;
        
        //set the rotation bases for our camera
        transform.SetRotationBases(forward, up, right);
        
        //make sure to clear out the translational delta of the mouse
        this.MouseDelta = local Real2(0.0, 0.0);
        
        //draw where our origin is so we can see what's going on
        this.DebugDrawOrigin();
    }
    
    function OnMouseDown(viewportMouseEvent : ViewportMouseEvent)
    {
        this.LeftMouseDown = true;
    }
    
    function OnMouseUp(viewportMouseEvent : ViewportMouseEvent)
    {
        this.LeftMouseDown = false;
    }
    
    function OnRightMouseDown(viewportMouseEvent : ViewportMouseEvent)
    {
        this.RightMouseDown = true;
    }
    
    function OnRightMouseUp(viewportMouseEvent : ViewportMouseEvent)
    {
        this.RightMouseDown = false;
    }
    
    function OnMouseMove(viewportMouseEvent : ViewportMouseEvent)
    {
        this.MouseDelta = viewportMouseEvent.Movement;
    }
    
    function OnMouseScroll(viewportMouseEvent : ViewportMouseEvent)
    {
        //just adjust the radius by the scroll wheel (this could be
        //modified to be an exponential zoom which tends to feel nicer)
        this.Radius -= viewportMouseEvent.Scroll.Y;
        this.Radius = Math.Clamp(this.Radius, this.MinDistance, this.MaxDistance);
    }
    
    function DebugDrawOrigin()
    {
        //draw a rotation sphere at our target if we're going to rotate the camera
        if(this.RightMouseDown || Zero.Keyboard.KeyIsDown(Keys.Q))
        {
            var sphere = new DebugSphere();
            sphere.Position(this.Target).Partial(true);
            sphere.Draw();
        }
        //draw a transform 'plus' if we're going to transform the camera
        else if(Zero.Keyboard.KeyIsDown(Keys.E))
        {
            var box = new DebugLineCross();
            box.Position(this.Target);
            box.Draw();
        }
    }
}
